<!-- Problem Statement:
    Draw a square. On every mouse click, rotate the square by 5 degrees about the lower left point. 
    Instead of calculating the values of cos and sin from JavaScript, do so from the shaders. 
    You are free to use lines, points, or any other modes of drawing to implement the square.
-->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Rotate on mouse click</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  
    
</head>
<body>
    <canvas id="canvas" width=600 height=600></canvas>
    <script>
            /*********************************************
                     INITIAL SETUP
            **********************************************/

            var canvas = document.getElementById('canvas');
            gl = canvas.getContext('experimental-webgl');

            // make canvas 1x1 with display
            // gl.canvas.width  = gl.canvas.clientWidth  * window.devicePixelRatio;
            // gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.clearColor(0.5, 0.5, 0.5, 1);
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.COLOR_BUFFER_BIT);

            /*********************************************
                     CREATE SHADER PROGRAMS
            **********************************************/


            /**********Vertex Shader**********************/
            var vertCode =
                'precision mediump float;'+
                'attribute vec3 position;'+
                'uniform float u_angle;'+
                'uniform float u_x;'+
                'uniform float u_y;'+
                'float angleRadian =  radians(u_angle);'+
                'float rotatedX = u_x * cos(u_angle) - u_y * sin(u_angle);'+
                'float rotatedY = u_y * cos(u_angle) + u_x * sin(u_angle);'+
                'void main(void) {'+
                 'if(u_x == 1.0){'+
                    'gl_Position = vec4((position.x * cos(0.0872665) - position.y * sin(0.0872665)),(position.y * cos(0.0872665) + position.x * sin(0.0872665)),0,1);'+
                   'gl_PointSize = 1.0;'+

                 '}'+
                '}';

            var vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);

            /**********Fragment Shader**********************/
            var fragCode =
                'precision mediump float;'+
                'void main(void) { '+
                'gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);'+
            
            '}';
            var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode);
            gl.compileShader(fragShader);

            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader); 
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);

    
            /*********************************************
                     SQUARE VERTICES
            **********************************************/
            var squareVertices = [
                 -0.2,0.6,
                 0.4,0.6,

                 -0.2,0.6,
                 -0.2,0.8,

                 -0.2,0.8,
                  0.4,0.8,

                  0.4,0.8,
                  0.4,0.6
            ];
           
            /*********************************************
                     BINDING VERTICES WITH SHADERS
            **********************************************/
 
            function drawElement(type,vertices,len) {
                var vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),gl.STATIC_DRAW);
                
                var position = gl.getAttribLocation(shaderProgram, 'position');
                gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(position);
                
                gl.drawArrays(type, 0, len);
            }

            /*********************************************
                     DRAW THE SQUARE
            **********************************************/
           
            drawElement(gl.LINES,squareVertices,8);
            var angle = gl.getUniformLocation(shaderProgram, "u_angle");
            var x = gl.getUniformLocation(shaderProgram, "u_x");
            var y = gl.getUniformLocation(shaderProgram, "u_y");
            canvas.onmousedown = function (ev) { click(ev, gl, canvas, angle,x,y); };
           function click(ev, gl, canvas, angle,x,y){
               
                 
                        var rotatingAngle = 0.0872665;
                        var click = 1.0;
                        //var rotatingAngle = Math.random();
                
                        console.log("Nothing is happening");
                        gl.uniform1f(angle,rotatingAngle);
                        gl.uniform1f(x,click);
                        // gl.uniform1f(y,rotationY);
                        console.log("Nothing is happening2");
                        gl.clearColor(0.5, 0.5, 0.5, 1);
                        gl.enable(gl.DEPTH_TEST);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        
                        drawElement(gl.LINES,squareVertices,8);
                        //var click = 0.0;
                        
                   
          }

    </script>
    
</body>
</html>